<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<# string[] typeHelper = new string[] { "String", "Array", "IList" }; #>
<# string[] type = new string[] { "String", "Array", "IList<IComparable>" }; #>
<# string[] length = new string[] { "Length", "Length", "Count" }; #>
<# string[] nullCondition = new string[] { 
    "string.IsNullOrEmpty(source) || string.IsNullOrEmpty(pattern)",
    "source == null || pattern == null || source.Length == 0 || pattern.Length == 0",
    "source == null || pattern == null || source.Count == 0 || pattern.Count == 0" }; #>
<# string[] compareEqual = new string[] {
    "source[i].Equals(pattern[j])", 
    "source.GetValue(i).Equals(pattern.GetValue(j))", 
    "source[i].Equals(pattern[j])"
    }; #>
<# string[] compareEqualNextVal = new string[] {
    "pattern[j].Equals(pattern[k])", 
    "pattern.GetValue(j).Equals(pattern.GetValue(k))", 
    "pattern[j].Equals(pattern[k])"
    }; #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace bitzhuwei.Algorithm.Common
{
<#  for (int i = 0; i < typeHelper.Length; i++)
    {
    #>
    public static class <#=typeHelper[i] #>KMP
    {
        /// <summary>
        /// This indicates that no pattern found from source.
        /// </summary>
        public const int KMPNoMatch = -1;
        /// <summary>
        /// Special value of next[] array, which means i should be increased by 1 and j sould be reset to 0.
        /// </summary>
        public const int FirstBlood = -1;
        /// <summary>
        /// Find first match for specified pattern in the source.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="pattern"></param>
        /// <returns></returns>
        public static int KMP(this <#=type[i]#> source, <#=type[i]#> pattern)
        {
            if (<#=nullCondition[i]#>)
            { return KMPNoMatch; }
            var i = 0; var j = 0; var result = KMPNoMatch;
            var nextVal = GetNextVal(pattern);

            while (i < source.<#=length[i]#> && j < pattern.<#=length[i]#>)
            {
                if (j == FirstBlood)
                {// source[i] does NOT equal with pattern[0], so i should be increased by 1 and j should be reset to 0.
                    i++; j = 0;
                }
                else if (<#=compareEqual[i]#>)
                {
                    i++; j++;
                }
                else
                {// Get next j that should be compared with.
                    j = nextVal[j];
                }
            }

            if (j >= pattern.<#=length[i]#>)// Match succeeded.
            { result = i - pattern.<#=length[i]#>; }

            return result;
        }
        /// <summary>
        /// nextVal[j]: source[i] should compare with pattern[ nextVal[j] ] in next loop
        /// <para>if source[i] does NOT equal with pattern[j].</para>
        /// <para>Specially, if source[i] does NOT equal with pattern[0], then i should be increased by 1</para>
        /// <para>and j should be reset to 0.</para>
        /// <para>So we should always set nextVal[0] = FirstBlood.</para>
        /// </summary>
        /// <param name="pattern"></param>
        /// <returns></returns>
        private static int[] GetNextVal(<#=type[i]#> pattern)
        {
            var j = 0; var k = -1;
            var nextVal = new int[pattern.<#=length[i]#>];

            nextVal[0] = FirstBlood;

            while (j < pattern.<#=length[i]#> - 1)
            {
                if ((k == -1) || (<#=compareEqualNextVal[i]#>))
                {
                    j++; k++;
                    if (!(<#=compareEqualNextVal[i]#>))
                    { nextVal[j] = k; }
                    else
                    { nextVal[j] = nextVal[k]; }
                }
                else
                { k = nextVal[k]; }
            }

            return nextVal;
        }
    }

<#
    }//end for
    #>
}