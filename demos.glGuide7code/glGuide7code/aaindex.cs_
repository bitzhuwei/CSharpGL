
using CSharpGL;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml.Linq;

namespace demos.glGuide7code {
    // Note: this is invalid for now. I don't want to fix this because I really don't need index mode even in legacy openGL.
    /*
 *  aaindex.c
 *  This program draws shows how to draw anti-aliased lines in color
 *  index mode. It draws two diagonal lines to form an X; when 'r' 
 *  is typed in the window, the lines are rotated in opposite 
 *  directions.
 */

    public unsafe class aaindex : _glGuide7code {
        const int RAMPSIZE = 16;
        const int RAMP1START = 32;
        const int RAMP2START = 48;
        float rotAngle = 0.0f;

        public aaindex(Form mainForm, int width, int height, GL gl)
            : base(mainForm, width, height, gl) { }

        public override void init(CSharpGL.GL gl) {
            for (var i = 0; i < RAMPSIZE; i++) {
                GLfloat shade;
                shade = (GLfloat)i / (GLfloat)RAMPSIZE;
                //glutSetColor(RAMP1START + (GLint)i, 0., shade, 0.);
                //glutSetColor(RAMP2START + (GLint)i, 0., 0., shade);
                gl.glIndexi(RAMP1START + (GLint)i); gl.glColor3f(0.0f, shade, 0.0f);
                gl.glIndexi(RAMP2START + (GLint)i); gl.glColor3f(0.0f, 0.0f, shade);
            }

            gl.glEnable(GL.GL_LINE_SMOOTH);
            gl.glHint(GL.GL_LINE_SMOOTH_HINT, GL.GL_DONT_CARE);
            gl.glLineWidth(1.5f);

            gl.glClearIndex((GLfloat)RAMP1START);
        }

        /// <summary>
        /// Draw 2 diagonal lines to form an X
        /// </summary>
        /// <param name="gl"></param>
        public override void display(CSharpGL.GL gl) {
            gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);

            gl.glIndexi(RAMP1START);
            gl.glPushMatrix();
            gl.glRotatef(-rotAngle, 0.0f, 0.0f, 0.1f);
            gl.glBegin(GL.GL_LINES);
            gl.glVertex2f(-0.5f, 0.5f);
            gl.glVertex2f(0.5f, -0.5f);
            gl.glEnd();
            gl.glPopMatrix();

            gl.glIndexi(RAMP2START);
            gl.glPushMatrix();
            gl.glRotatef(rotAngle, 0.0f, 0.0f, 0.1f);
            gl.glBegin(GL.GL_LINES);
            gl.glVertex2f(0.5f, 0.5f);
            gl.glVertex2f(-0.5f, -0.5f);
            gl.glEnd();
            gl.glPopMatrix();

            gl.glFlush();


        }

        public override void reshape(CSharpGL.GL gl, int w, int h) {
            gl.glViewport(0, 0, (GLsizei)w, (GLsizei)h);
            gl.glMatrixMode(GL.GL_PROJECTION);
            gl.glLoadIdentity();
            if (w <= h) {
                //gl.gluOrtho2D(-1.0f, 1.0f, -1.0f * (GLfloat)h / (GLfloat)w, 1.0f * (GLfloat)h / (GLfloat)w);
                glu.Ortho2D(-1.0f, 1.0f, -1.0f * (GLfloat)h / (GLfloat)w, 1.0f * (GLfloat)h / (GLfloat)w);
            }
            else {
                //gl.gluOrtho2D(-1.0f * (GLfloat)w / (GLfloat)h, 1.0f * (GLfloat)w / (GLfloat)h, -1.0f, 1.0f);
                glu.Ortho2D(-1.0f * (GLfloat)w / (GLfloat)h, 1.0f * (GLfloat)w / (GLfloat)h, -1.0f, 1.0f);
            }
            gl.glMatrixMode(GL.GL_MODELVIEW);
            gl.glLoadIdentity();
        }
        public override void mouse(MouseButtons button, MouseState state, int x, int y) {
        }
        public override void keyboard(CSharpGL.GL gl, Keys key, int x, int y) {
            switch (key) {
            case Keys.T:
            rotAngle += 20.0f;
            if (rotAngle >= 360.0f) { rotAngle = 0.0f; }
            //gl.glutPostRedisplay();
            this.mainForm.Invalidate();
            break;
            case Keys.Escape:// (char)27:  /*  Escape Key */
            //exit(0);
            this.mainForm.Close();
            break;
            default:
            break;
            }

        }

        public override Keys[] ValidKeys => [Keys.T];
        public override MouseButtons[] ValidButtons => [];

    }
}