using System;
using System.Collections.Generic;

namespace SoftGLImpl {
    unsafe partial class SoftGL {


        public static GLuint glCreateProgram() {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return 0; }

            var name = context.nextShaderProgramName;
            var program = new GLProgram(name);
            context.name2Program.Add(name, program);
            context.nextShaderProgramName++;

            return name;
        }

        public static void glAttachShader(GLuint programName, GLuint shaderName) {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return; }

            if (programName == 0 || shaderName == 0) { context.ErrorCode = (uint)(ErrorCode.InvalidValue); return; }
            if ((!context.name2Program.TryGetValue(programName, out var program)) || (!context.name2Shader.TryGetValue(shaderName, out var shader))) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }

            if (program.AttachedShaders.Contains(shader)) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }

            program.AttachedShaders.Add(shader);
        }

        public static void glLinkProgram(GLuint name) {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return; }

            if (name == 0) { context.ErrorCode = (uint)(ErrorCode.InvalidValue); return; }
            if (!context.name2Program.TryGetValue(name, out var program)) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
            // TODO: GL_INVALID_OPERATION is generated if program​ is the currently active program object and transform feedback mode is active.

            program.Link();
        }

        public static unsafe GLint glGetAttribLocation(GLuint programName, IntPtr name) {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return -1; }

            if ((programName == 0) || (!context.name2Program.TryGetValue(programName, out var program))) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return -1; }
            // TODO: GL_INVALID_OPERATION is generated if program​ has not been successfully linked.

            var str = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(name);
            if (str == null) { return -1; }
            else { return program.GetAttribLocation(str); }
        }

        public static void glUseProgram(GLuint name) {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return; }

            /*
GL_INVALID_VALUE     is generated if program is neither 0 nor a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program could not be made part of current state.
GL_INVALID_OPERATION is generated if transform feedback mode is active.
             */

            if (name == 0) { context.currentShaderProgram = null; }
            else {
                if (!context.name2Program.TryGetValue(name, out var program)) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
                if (program.LogInfo != string.Empty) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
                // TODO: GL_INVALID_OPERATION is generated if transform feedback mode is active.

                context.currentShaderProgram = program;
            }
        }

        public static unsafe void glGetProgramiv(GLuint name, GLenum pname, GLint* pValues) {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return; }

            if (!context.name2Program.TryGetValue(name, out var program)) { context.ErrorCode = (uint)(ErrorCode.InvalidValue); return; }
            if (program == null) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
            if (program.LogInfo != string.Empty) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
            if (!Enum.IsDefined(typeof(GetProgramivPName), pname)) { context.ErrorCode = (uint)(ErrorCode.InvalidEnum); return; }
            if (pname == (GLenum)GetProgramivPName.GeometryVerticesOut
                || pname == (GLenum)GetProgramivPName.GeometrInputType
                || pname == (GLenum)GetProgramivPName.GeometryOutputType) {
                if (program.GeometryShader == null) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
            }
            if (pname == (GLenum)GetProgramivPName.ComputeWorkGroupSize && program.ComputeShader == null) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }

            switch ((GetProgramivPName)pname) {// TODO: fill in the blanks of glGetProgramiv(..).
            case GetProgramivPName.DeleteSataus:
            break;
            case GetProgramivPName.LinkStatus:
            //if (pValues != null && pValues.Length > 0) { pValues[0] = (int)(program.LogInfo == string.Empty ? GL.GL_TRUE : GL.GL_FALSE); }
            if (pValues != null) { pValues[0] = (int)(program.LogInfo == string.Empty ? GL.GL_TRUE : GL.GL_FALSE); }
            break;
            case GetProgramivPName.ValidateStatus:
            break;
            case GetProgramivPName.InfoLogLength:
            break;
            case GetProgramivPName.AttachedShaders:
            break;
            case GetProgramivPName.ActiveAtmoicCounterBuffers:
            break;
            case GetProgramivPName.ActiveAttributes:
            break;
            case GetProgramivPName.ActiveAttributeMaxLength:
            break;
            case GetProgramivPName.ActiveUniforms:
            break;
            case GetProgramivPName.ActiveUniformBlocks:
            break;
            case GetProgramivPName.ActiveUniformBlockMaxNameLength:
            break;
            case GetProgramivPName.ActiveUniformMaxLength:
            break;
            case GetProgramivPName.ComputeWorkGroupSize:
            break;
            case GetProgramivPName.ProgramBinaryLength:
            break;
            case GetProgramivPName.TransformFeedbackBufferMode:
            break;
            case GetProgramivPName.TransformFeedbackVaryings:
            break;
            case GetProgramivPName.TransformFeedbackVaryingMaxLength:
            break;
            case GetProgramivPName.GeometryVerticesOut:
            break;
            case GetProgramivPName.GeometrInputType:
            break;
            case GetProgramivPName.GeometryOutputType:
            break;
            default:
            throw new NotDealWithNewEnumItemException(typeof(GetProgramivPName));
            }
        }

        public static void glDetachShader(GLuint program, GLuint shader) {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return; }

            if (program == 0 || shader == 0) { context.ErrorCode = (uint)(ErrorCode.InvalidValue); return; }
            if (!context.name2Program.TryGetValue(program, out var programObj)) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
            if (!context.name2Shader.TryGetValue(shader, out var shaderObj)) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }
            if (!programObj.AttachedShaders.Contains(shaderObj)) { context.ErrorCode = (uint)(ErrorCode.InvalidOperation); return; }

            programObj.AttachedShaders.Remove(shaderObj);
        }

        /*
            glDeleteProgram frees the memory and invalidates the name associated with the program object specified by program.​ This command effectively undoes the effects of a call to glCreateProgram.
   If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to glDeleteShader. A value of 0 for program​ will be silently ignored.
   To determine whether a program object has been flagged for deletion, call glGetProgram with arguments program​ and GL_DELETE_STATUS.
   */
        public static void glDeleteProgram(GLuint name) {
            var context = SoftGL.GetCurrentContextObj();
            if (context == null) { return; }

            if (!context.name2Program.TryGetValue(name, out var program)) { context.ErrorCode = (uint)(ErrorCode.InvalidValue); return; }

            context.name2Program.Remove(name);
            program.deleteFlag = true;
        }
    }

    enum GetProgramivPName : uint {
        DeleteSataus = GL.GL_DELETE_STATUS,
        LinkStatus = GL.GL_LINK_STATUS,
        ValidateStatus = GL.GL_VALIDATE_STATUS,
        InfoLogLength = GL.GL_INFO_LOG_LENGTH,
        AttachedShaders = GL.GL_ATTACHED_SHADERS,
        ActiveAtmoicCounterBuffers = GL.GL_ACTIVE_ATOMIC_COUNTER_BUFFERS,
        ActiveAttributes = GL.GL_ACTIVE_ATTRIBUTES,
        ActiveAttributeMaxLength = GL.GL_ACTIVE_ATTRIBUTE_MAX_LENGTH,
        ActiveUniforms = GL.GL_ACTIVE_UNIFORMS,
        ActiveUniformBlocks = GL.GL_ACTIVE_UNIFORM_BLOCKS,
        ActiveUniformBlockMaxNameLength = GL.GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH,
        ActiveUniformMaxLength = GL.GL_ACTIVE_UNIFORM_MAX_LENGTH,
        ComputeWorkGroupSize = GL.GL_COMPUTE_WORK_GROUP_SIZE,
        ProgramBinaryLength = GL.GL_PROGRAM_BINARY_LENGTH,
        TransformFeedbackBufferMode = GL.GL_TRANSFORM_FEEDBACK_BUFFER_MODE,
        TransformFeedbackVaryings = GL.GL_TRANSFORM_FEEDBACK_VARYINGS,
        TransformFeedbackVaryingMaxLength = GL.GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH,
        GeometryVerticesOut = GL.GL_GEOMETRY_VERTICES_OUT,
        GeometrInputType = GL.GL_GEOMETRY_INPUT_TYPE,
        GeometryOutputType = GL.GL_GEOMETRY_OUTPUT_TYPE
    }
}
