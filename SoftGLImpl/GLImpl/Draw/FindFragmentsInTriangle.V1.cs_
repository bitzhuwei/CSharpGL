using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Http.Headers;
using System.Reflection.Metadata.Ecma335;
using System.Text;

namespace SoftGLImpl {
    unsafe partial class SoftGL {

        /// <summary>
        /// Find fragments in the specified triangle.
        /// </summary>
        /// <param name="fragCoord0"></param>
        /// <param name="fragCoord1"></param>
        /// <param name="fragCoord2"></param>
        /// <param name="endpoints0"></param>
        /// <param name="endpoints1"></param>
        /// <param name="endpoints2"></param>
        /// <param name="result"></param>
        unsafe private static void FindFragmentsInTriangle_V1(vec3 fragCoord0, vec3 fragCoord1, vec3 fragCoord2,
            VertexCodeBase endpoints0, VertexCodeBase endpoints1, VertexCodeBase endpoints2,
            ConcurrentBag<Fragment> result) {
            //var pixelList = new List<vec3>();
            var points = new List<Pixel3>();
            FindPixelsAtLine(fragCoord0, fragCoord1, points);
            FindPixelsAtLine(fragCoord0, fragCoord2, points);
            FindPixelsAtLine(fragCoord1, fragCoord2, points);
            var groups = from item in points
                         group item by (item.x) into g
                         orderby g.Key ascending
                         select g;
            var matrix = new mat3(fragCoord0, fragCoord1, fragCoord2);
            var inverseMat = CodeBase.inverse(matrix);
            foreach (var g in groups) {// find pixels in each vertical line.
                //var pointsAtLine = new List<int>();
                var min = new Pixel3(); var max = new Pixel3(); bool first = true;
                foreach (var pixel in g) {
                    if (first) { min = pixel; max = pixel; first = false; }
                    else {
                        if (pixel.y < min.y) { min = pixel; }
                        if (max.y < pixel.y) { max = pixel; }
                    }
                    //pointsAtLine.Add((int)(pixel.y));
                }
                Debug.Assert(min.x == max.x);
                if (min.y == max.y) {
                    var pixel = new vec3(min.x + 0.5f, min.y + 0.5f, min.depth);
                    //Debug.Assert(x > -10000 && x < 10000 && y > -10000 && y < 10000 && z > -10000 && z < 10000);
                    vec3 p012 = inverseMat * pixel;
                    //// note: "sum" is not needed.
                    // float sum = p012.x + p012.y + p012.z;
                    //// note: so, just need to assign values to p0, p1, p2.
                    //var p0 = p012.x; var p1 = p012.y; var p2 = p012.z;
                    var fragment = new Fragment(pixel, endpoints0, endpoints1, endpoints2, p012.x, p012.y, p012.z);
                    result.Add(fragment);
                }
                else {
                    //min.y += 0.5f;
                    //max.y += 0.5f;
                    for (int y = min.y; y <= max.y; y++) {
                        //if (pointsAtLine.Contains(y)) { continue; }

                        float alpha = (y + 0.5f - min.y) / (max.y - min.y);
                        //float x = min.x + alpha * (max.x - min.x) * alpha;
                        float z = min.depth + alpha * (max.depth - min.depth);
                        //var pixel = new vec3(x, y - 0.5f, z);
                        var pixel = new vec3(min.x + 0.5f, y + 0.5f, z);// pixel.x += 0.5f; pixel.y += 0.5f;
                        Debug.Assert(min.x > -10000 && min.x < 10000 && y > -10000 && y < 10000 && z > -10000 && z < 10000);
                        vec3 p012 = inverseMat * pixel;
                        //// note: "sum" is not needed.
                        // float sum = p012.x + p012.y + p012.z;
                        //// note: so, just need to assign values to p0, p1, p2.
                        //var p0 = p012.x; var p1 = p012.y; var p2 = p012.z;
                        var fragment = new Fragment(pixel, endpoints0, endpoints1, endpoints2, p012.x, p012.y, p012.z);
                        result.Add(fragment);
                    }
                }
            }
            //OnSamePlane(fragCoord0, fragCoord1, fragCoord2, pixelList);
            //foreach (var pixel in pixelList) {// for each pixel at this line..
            //    //LinearInterpolationTriangle(pixel, fragCoord0, fragCoord1, fragCoord2, out p0, out p1, out p2);
            //    var matrix = new mat3(fragCoord0, fragCoord1, fragCoord2);
            //    vec3 p012 = CodeBase.inverse(matrix) * pixel;
            //    // note: "sum" is not needed.
            //    //float sum = p012.x + p012.y + p012.z;
            //    //p0 = p012.x / sum; p1 = p012.y / sum; p2 = p012.z / sum;
            //    // note: so, just need to assign values to p0, p1, p2.
            //    //p0 = p012.x; p1 = p012.y; p2 = p012.z;
            //    var fragment = new Fragment(pixel, endpoints0, endpoints1, endpoints2, p012.x, p012.y, p012.z);
            //    result.Add(fragment);
            //}
            //var matrix = new mat3(fragCoord0, fragCoord1, fragCoord2);
            //Parallel.For(0, pixelList.Count, t => {
            //    var pixel = pixelList[t];
            //    vec3 p012 = CodeBase.inverse(matrix) * pixel;
            //    //var p0 = p012.x; var p1 = p012.y; var p2 = p012.z;
            //    var fragment = new Fragment(pixel, endpoints0, endpoints1, endpoints2, p012.x, p012.y, p012.z);
            //    result.Add(fragment);
            //});
        }

        //private static void LinearInterpolationTriangle(vec3 pixel, vec3 fragCoord0, vec3 fragCoord1, vec3 fragCoord2, out float p0, out float p1, out float p2) {
        //    var matrix = new mat3(fragCoord0, fragCoord1, fragCoord2);
        //    vec3 p012 = CodeBase.inverse(matrix) * pixel;
        //    // note: "sum" is not needed.
        //    //float sum = p012.x + p012.y + p012.z;
        //    //p0 = p012.x / sum; p1 = p012.y / sum; p2 = p012.z / sum;
        //    // note: so, just need to assign values to p0, p1, p2.
        //    p0 = p012.x; p1 = p012.y; p2 = p012.z;
        //}

        private static void LinearInterpolationTriangle_Old(vec3 pixel,
            vec3 fragCoord0, vec3 fragCoord1, vec3 fragCoord2,
            out float p0, out float p1, out float p2) {
            float j0 = 0, j1 = 0, j2 = 0;
            {
                // 0 1 2 : A B C
                vec3 p = pixel - fragCoord0;
                vec3 b = fragCoord1 - fragCoord0;
                vec3 c = fragCoord2 - fragCoord0;

                j0 = GetJ(p, b, c);
            }
            {
                // 1 2 0 : B C A
                vec3 p = pixel - fragCoord1;
                vec3 b = fragCoord2 - fragCoord1;
                vec3 c = fragCoord0 - fragCoord1;

                j1 = GetJ(p, b, c);
            }
            {
                // 2 0 1: C A B
                vec3 p = pixel - fragCoord2;
                vec3 b = fragCoord0 - fragCoord2;
                vec3 c = fragCoord1 - fragCoord2;

                j2 = GetJ(p, b, c);
            }

            float sum = j0 + j1 + j2;
            p0 = j0 / sum; p1 = j1 / sum; p2 = j2 / sum;
            if (p0 < 0 || p1 < 0 || p2 < 0) {
                throw new Exception("Error");
            }
        }

        private static float GetJ(vec3 p, vec3 b, vec3 c) {
            float j = 0.0f;
            {
                var matrix = new mat2(p.x, p.y, b.x - c.x, b.y - c.y);
                mat2 inversed = CodeBase.inverse(matrix);
                //mat2 one = inversed * matrix; Console.WriteLine(one);
                vec2 result = CodeBase.inverse(matrix) * new vec2(b.x, b.y);
                j += result.x;
            }
            {
                var matrix = new mat2(p.x, p.z, b.x - c.x, b.z - c.z);
                mat2 inversed = CodeBase.inverse(matrix);
                //mat2 one = inversed * matrix; Console.WriteLine(one);
                vec2 result = CodeBase.inverse(matrix) * new vec2(b.x, b.z);
                j += result.x;
            }
            {
                var matrix = new mat2(p.y, p.z, b.y - c.y, b.z - c.z);
                mat2 inversed = CodeBase.inverse(matrix);
                //mat2 one = inversed * matrix; Console.WriteLine(one);
                vec2 result = CodeBase.inverse(matrix) * new vec2(b.y, b.z);
                j += result.x;
            }

            j = j / 3.0f;
            return j;
        }

        //private static bool OnSameLine(vec3 p0, vec3 p1, List<vec3> result) {
        //    bool sameLine = true;
        //    vec3 p01 = p1 - p0;
        //    float length = p01.length();
        //    foreach (var item in result) {
        //        vec3 other = item - (p0 + p1) / 2;
        //        float otherLength = other.length();
        //        float sum = Math.Abs(other.dot(p01));
        //        float diff = length * otherLength - sum;
        //        if (diff / sum > 0.01f) {
        //            sameLine = false;
        //        }
        //    }

        //    return sameLine;
        //}
        //private static bool OnSamePlane(vec3 p0, vec3 p1, vec3 p2, List<vec3> result) {
        //    bool samePlane = true;

        //    vec3 p01 = p1 - p0; vec3 p02 = p2 - p0;
        //    vec3 direction = p01.cross(p02);
        //    float A = direction.x, B = direction.y, C = direction.z;
        //    // A(x - p0.x) + B(y - p0.y) + C(z - p0.z) = 0
        //    // Ax + By + Cz + D = 0
        //    float D = -direction.dot(p0);
        //    float length = direction.length();
        //    direction = direction / length;
        //    D = D / length;
        //    {
        //        float diff = direction.dot(p0) + D;
        //        Console.WriteLine(diff);
        //    }
        //    {
        //        float diff = direction.dot(p1) + D;
        //        Console.WriteLine(diff);
        //    }
        //    {
        //        float diff = direction.dot(p2) + D;
        //        Console.WriteLine(diff);
        //    }
        //    for (int i = 0; i < result.Count; i++) {
        //        vec3 p = new vec3(result[i]);
        //        float diff = direction.dot(p) + D;
        //        if (Math.Abs(diff) / direction.length() > 0.01f) {
        //            //Console.WriteLine("Not same plane!");
        //            samePlane = false;
        //        }
        //    }

        //    return samePlane;
        //}

    }
}
