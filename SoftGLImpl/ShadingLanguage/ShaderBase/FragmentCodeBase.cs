using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SoftGLImpl {
    public abstract partial class FragmentCodeBase : CodeBase {
        /// <summary>
        /// The location of the fragment in window space. The X, Y and Z components are the window-space position of the fragment. The Z value will be written to the depth buffer if gl_FragDepth is not written to by this shader stage. The W component of gl_FragCoord is 1/Wclip, where Wclip is the interpolated W component of the clip-space vertex position output to gl_Position from the last Vertex Processing stage.
        /// </summary>
        //[InAttribute]
        public vec4 gl_FragCoord;
        /// <summary>
        /// This is false if the fragment was generated by the back-face of the primitive; it is true in all other cases (including Primitives that have no back face).
        /// </summary>
        //[InAttribute]
        public bool gl_FrontFacing;
        /// <summary>
        /// The location within a point primitive that defines the position of the fragment relative to the side of the point. Points are effectively rasterized as window-space squares of a certain pixel size. Since points are defined by a single vertex, the only way to tell where in that square a particular fragment is is with gl_PointCoord.
        /// <para>The values of gl_PointCoord's coordinates range from [0, 1]. OpenGL uses a upper-left origin for point-coordinates by default, so (0, 0) is the upper-left. However, the origin can be switched to a bottom-left origin by calling glPointParameteri(GL_POINT_SPRITE_COORD_ORIGIN, GL_LOWER_LEFT);</para>
        /// </summary>
        //[InAttribute]
        public vec2 gl_PointCoord;

        /// <summary>
        /// This is an integer identifier for the current sample that this fragment is rasterized for.
        /// <para>Warning: Any use of this variable at all will force this shader to be evaluated per-sample. Since much of the point of multisampling is to avoid that, you should use it only when you must.</para>
        /// </summary>
        //[InAttribute]
        public int gl_SampleID;
        /// <summary>
        /// This is the location of the current sample for the fragment within the pixel's area, with values on the range [0, 1]. The origin is the bottom-left of the pixel area.
        /// <para>Warning: Any use of this variable at all will force this shader to be evaluated per-sample. Since much of the point of multisampling is to avoid that, you should use it only when you must.</para>
        /// </summary>
        //[InAttribute]
        public vec2 gl_SamplePosition;
        /// <summary>
        /// When using multisampling, this variable contains a bitfield for the sample mask of the fragment being generated. The array is as long as needed to fill in the number of samples supported by the GL implementation.
        /// </summary>
        //[InAttribute]
        public int[] gl_SampleMaskIn;
        /// <summary>
        /// This array contains the interpolated clipping plane half-spaces, as output for vertices from the last Vertex Processing stage.
        /// </summary>
        //[InAttribute]
        public float[] gl_ClipDistance;
        /// <summary>
        /// This value is the index of the current primitive being rendered by this drawing command. This includes any Tessellation applied to the mesh, so each individual primitive will have a unique index.
        /// <para>However, if a Geometry Shader is active, then the gl_PrimitiveID is exactly and only what the GS provided as output. Normally, gl_PrimitiveID is guaranteed to be unique, so if two FS invocations have the same primitive ID, they come from the same primitive. But if a GS is active and outputs non-unique values, then different fragment shader invocations for different primitives will get the same value. If the GS did not output a value for gl_PrimitiveID, then the fragment shader gets an undefined value.</para>
        /// </summary>
        //[InAttribute]
        public int gl_PrimitiveID;

        /// <summary>
        /// This is either 0 or the layer number for this primitive output by the Geometry Shader.
        /// </summary>
        //[InAttribute]
        public int gl_Layer;
        /// <summary>
        /// This is either 0 or the viewport index for this primitive output by the Geometry Shader.
        /// </summary>
        //[InAttribute]
        public int gl_ViewportIndex;

        /// <summary>
        /// This output is the fragment's depth. If the shader does not statically write this value, then it will take the value of gl_FragCoord.z.
        /// <para>To "statically write" to a variable means that you write to it anywhere in the program. Even if the writing code is technically unreachable for some reason, if there is a gl_FragDepth = ... expression anywhere in the shader, then it is statically written.</para>
        /// </summary>
        //[OutAttribute]
        public float gl_FragDepth;

        /// <summary>
        /// This defines the sample mask for the fragment when performing mutlisampled rendering. If a shader does not statically write to it, then it will be filled in by gl_SampleMaskIn. The sample mask output here will be logically AND'd with the sample mask computed by the rasterizer.
        /// <para>Warning: Just as with gl_FragDepth, if a fragment shader writes to gl_SampleMask at all, it must make sure to write to the value for all execution paths. But it must also make sure to write to each element in the array. The array has the same size as gl_SampleMaskIn.</para>
        /// </summary>
        //[OutAttribute]
        public int[] gl_SampleMask;

        /// <summary>
        /// "discard" in GLSL.
        /// </summary>
        public bool discard { get; protected set; }

    }
}
