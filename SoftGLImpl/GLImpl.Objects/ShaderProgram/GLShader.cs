using bitzhuwei.Compiler;
using bitzhuwei.GLSLFormat;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.CSharp;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace SoftGLImpl {
    abstract class GLShader {
        public static GLShader? Create(GLenum type, uint id) {
            GLShader? result = null;
            switch ((Kind)type) {
            case GLShader.Kind.VertexShader: result = new GLVertexShader(id); break;
            case GLShader.Kind.TessControlShader: result = new GLTessControlShader(id); break;
            case GLShader.Kind.TessEvaluationShader: result = new GLTessEvaluationShader(id); break;
            case GLShader.Kind.GeometryShader: result = new GLGeometryShader(id); break;
            case GLShader.Kind.FragmentShader: result = new GLFragmentShader(id); break;
            case GLShader.Kind.ComputeShader: result = new GLComputeShader(id); break;
            default: throw new NotImplementedException();
            }

            return result;
        }

        /// <summary>
        /// Compiling error information.
        /// </summary>
        private string infoLog = string.Empty;
        /// <summary>
        /// methods.
        /// </summary>
        //protected CompilerResults compiledCode;
        protected Assembly? compiledAssembly;
        //protected Script<object> compiledScript;
        public Type? codeType;
        public ObjectPool? scriptPool;
        public readonly Dictionary<string, FieldInfo> name2fielfInfo = new();
        protected Dictionary<string, UniformVariable> name2uniformVar = new();

        /// <summary>
        /// Name -> field.
        /// </summary>
        public Dictionary<string, UniformVariable> Name2uniformVar { get { return name2uniformVar; } }

        /// <summary>
        /// Compiling error information.
        /// </summary>
        public string InfoLog { get { return infoLog; } }

        // TODO: use byte*[] ?
        /// <summary>
        /// Source code of shader.
        /// </summary>
        public string Code { get; set; } = "";

        public Kind ShaderType { get; private set; }

        /// <summary>
        /// name generated by glCreateShader().
        /// </summary>
        public uint Id { get; private set; }

        /// <summary>
        /// Creates a program object.
        /// </summary>
        /// <param name="shaderType"></param>
        /// <param name="id"></param>
        public GLShader(Kind shaderType, uint id) {
            this.ShaderType = shaderType;
            this.Id = id;
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override string ToString() {
            return string.Format("Shader: Id:{0}", this.Id);
        }

        protected abstract string AfterCompile();

        private static readonly CompilerGLSL glslParser = new();
        private static readonly Dictionary<Kind, string> kind2base = new() {
            { Kind.VertexShader, nameof(VertexCodeBase) },
            { Kind.TessControlShader, nameof(TessControlCodeBase) },
            { Kind.TessEvaluationShader, nameof(GLTessEvaluationShader) },
            { Kind.GeometryShader, nameof(GeometryCodeBase) },
            { Kind.FragmentShader, nameof(FragmentCodeBase) },
            { Kind.ComputeShader, nameof(ComputeCodeBase) },
        };
        public void Compile() {
            string source = this.Code;
            //var tokens = glslParser.Analyze(source);
            var tokens = Preprocessor.Preprocess(source);
            var tree = glslParser.Parse(tokens);
            var translation_unit = glslParser.Extract(tree, tokens, source);
            if (translation_unit == null) { this.infoLog = $"failed to transform from glsl to C# code"; return; }
            var builder = new StringBuilder();
            builder.AppendLine($"using {nameof(SoftGLImpl)};");
            builder.AppendLine($"class {this.ShaderType} : {kind2base[this.ShaderType]} {{");
            using (var writer = new StringWriter(builder)) {
                var config = new BlankConfig(inlineBlank: 0, forceNewline: false);
                var context = new FormatContext(tokens, tabUnit: 4, tabCount: 0);
                translation_unit.FullFormat(config, writer, context);
            }
            builder.AppendLine();
            builder.AppendLine("}");
            var csCode = builder.ToString();

            //var script = CSharpScript.Create(csCode);
            var assem = Compile2Assembly(csCode, out var error);
            //var result = await script.RunAsync();
            //var options = new Dictionary<string, string>();
            //options.Add("CompilerVersion", "v3.5");
            //var compiler = new CSharpCodeProvider(options);
            //var compParameters = new CompilerParameters();
            //compParameters.ReferencedAssemblies.Add("system.core.dll");
            //compParameters.ReferencedAssemblies.Add("SoftGL.dll");
            //compParameters.ReferencedAssemblies.Add("SoftGL.ShadingLanguage.dll");

            //CompilerResults res = compiler.CompileAssemblyFromSource(compParameters, csCode);

            //if (res.Errors.Count > 0) { this.infoLog = DumpLog(res); return; }
            Type? codeType = null;
            if (assem != null) { codeType = this.FindShaderCodeType(assem, this.ShaderType.GetShaderCodeType()); }
            if (codeType == null) { this.infoLog = string.Format("No {0} found!", this.ShaderType); return; }
            this.scriptPool = new ObjectPool(codeType);
            string result = FindUniformVariables(codeType, this.name2uniformVar);
            if (result != string.Empty) { this.infoLog = result; return; }

            //this.compiledCode = res;
            this.compiledAssembly = assem;
            this.codeType = codeType;

            this.infoLog = this.AfterCompile();
        }
        private static Assembly? Compile2Assembly(string sourceCode, out string error) {
            // 解析语法树
            var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);

            // 设置编译选项
            string assemblyName = Path.GetRandomFileName();
            CSharpCompilationOptions options = new CSharpCompilationOptions(
                OutputKind.DynamicallyLinkedLibrary); // 生成类库

            // 自动加载所有已加载的程序集引用
            //MetadataReference[] references = AppDomain.CurrentDomain
            //    .GetAssemblies()
            //    .Where(a => !a.IsDynamic)
            //    .Select(a => MetadataReference.CreateFromFile(a.Location))
            //    .ToArray();
            var references = new List<MetadataReference>();
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (var assembly in assemblies) {
                if (assembly.IsDynamic) { continue; }
                if (string.IsNullOrEmpty(assembly.Location)) { continue; }
                var reference = MetadataReference.CreateFromFile(assembly.Location);
                references.Add(reference);
            }

            // 创建编译对象
            CSharpCompilation compilation = CSharpCompilation.Create(
                assemblyName,
                new[] { syntaxTree },
                references,
                options);

            // 编译到内存流
            using MemoryStream ms = new MemoryStream();
            EmitResult result = compilation.Emit(ms);

            // 处理编译错误
            if (!result.Success) {
                error = DumpLog(result);
                return null;
            }
            else {
                error = "";
                // 加载程序集
                ms.Seek(0, SeekOrigin.Begin);
                return Assembly.Load(ms.ToArray());
            }
        }
        /// <summary>
        /// Creates an instance of executable shader code.
        /// </summary>
        /// <returns></returns>
        public abstract object? ApplyCodeInstance();

        private string FindUniformVariables(Type shaderCodeType, Dictionary<string, UniformVariable> dict) {
            dict.Clear();
            foreach (var item in shaderCodeType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly)) {
                object[] inAttribute = item.GetCustomAttributes(typeof(uniformAttribute), false);
                if (inAttribute != null && inAttribute.Length > 0) // this is a 'uniform ...;' field.
                {
                    var v = new UniformVariable(item);
                    dict.Add(item.Name, v);
                }
            }

            return string.Empty;
        }

        protected Type? FindShaderCodeType(Assembly assembly, Type shaderCodeType) {
            Type? result = null;
            Type[] types = assembly.GetTypes();
            foreach (var item in types) {
                if (item.BaseType == shaderCodeType) {
                    result = item;
                    break;
                }
            }

            return result;
        }

        public unsafe void GetShaderStatus(ShaderStatus pname, int* pValues) {
            //if (pValues == null || pValues.Length < 1) { return; }
            if (pValues == null) { return; }

            switch (pname) {
            case ShaderStatus.ShaderType:
            pValues[0] = (int)this.ShaderType;
            break;
            case ShaderStatus.DeleteStatus:
            throw new NotImplementedException();
            case ShaderStatus.CompileStatus:
            pValues[0] = this.infoLog.Length == 0 ? (int)GL.GL_TRUE : (int)GL.GL_FALSE;
            break;
            case ShaderStatus.InfoLogLength:
            pValues[0] = this.infoLog.Length;
            break;
            case ShaderStatus.ShaderSourceLength:
            string code = this.Code;
            if (code == null) { pValues[0] = 0; }
            else { pValues[0] = code.Length; }
            break;
            default:
            throw new NotImplementedException();
            }
        }

        protected static string DumpLog(EmitResult/*CompilerResults*/ result) {
            //var builder = new StringBuilder();
            //if (res != null) {
            //    foreach (var item in res.Errors) {
            //        builder.AppendLine(item.ToString());
            //    }
            //}
            //return builder.ToString();
            var errors = result.Diagnostics
                               .Where(d => d.IsWarningAsError || d.Severity == DiagnosticSeverity.Error)
                               .Select(d => $"{d.Id}: {d.GetMessage()}")
                               .Aggregate((current, next) => current + "\n" + next);
            return errors;
        }

        public enum Kind : uint {
            VertexShader = GL.GL_VERTEX_SHADER,
            GeometryShader = GL.GL_GEOMETRY_SHADER,
            TessControlShader = GL.GL_TESS_CONTROL_SHADER,
            TessEvaluationShader = GL.GL_TESS_EVALUATION_SHADER,
            FragmentShader = GL.GL_FRAGMENT_SHADER,
            ComputeShader = GL.GL_COMPUTE_SHADER,
        }
    }
}
